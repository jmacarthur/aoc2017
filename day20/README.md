Part 1 (solve20a.py) calculates the position directly for very large cycle times, rather than iteratively. The calculation in there is wrong - it uses the final value of velocity to calculate position, rather than the sum of all previous velocity. At a very large cycle time, however, this error disappears and we get the right answer.

Part 2 (solve2b.py) iterates through the positions of all particles, removing them when they collide. It would also be possible to use the quadratic formula to determine the times when two particles collide. I tried implementing this - there's a lot of corner cases to account for, and it is actually slower to do it this way, as the number of particles (and thus collision checks) is large compared to the number of cycles in which collisions occur. Solving the quadratic equation for each pair of particles does tell you though that the solutions (collisions) are all before cycle 50, so we can be confident in stopping the iterative solution around then.